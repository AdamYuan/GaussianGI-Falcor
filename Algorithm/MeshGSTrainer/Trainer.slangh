#pragma once

import GaussianGI.Algorithm.GS3D;

#define ALPHA_THRESHOLD (1.0 / 255.0)
#define QUAD_POS_BOUND 2.3539888583335364 // Q
// \alpha = \exp{-Q^2} = \frac{1}{255} = \text{ALPHA_THRESHOLD}
// \Rightarrow Q = \sqrt{\ln{255}}

struct Splat : IDifferentiable
{
    float3 mean;
    float3 scale;
    float4 rotate;
};

struct SplatBuffer
{
    StructuredBuffer<float4> means_scaleXs;
    StructuredBuffer<float2> scaleYZs;
    StructuredBuffer<float4> rotates;

    Splat load(uint splatID)
    {
        Splat splat;
        float4 mean_scaleX = means_scaleXs[splatID];
        float2 scaleYZ = scaleYZs[splatID];
        float4 rotate = rotates[splatID];
        splat.mean = mean_scaleX.xyz;
        splat.scale = float3(mean_scaleX.w, scaleYZ);
        splat.rotate = rotate;
        return splat;
    }
};

struct RWSplatBuffer
{
    RWStructuredBuffer<float4> rotates;
    RWStructuredBuffer<float4> means_scaleXs;
    RWStructuredBuffer<float2> scaleYZs;

    void store(uint splatID, in const Splat splat)
    {
        rotates[splatID] = splat.rotate;
        means_scaleXs[splatID] = float4(splat.mean, splat.scale.x);
        scaleYZs[splatID] = splat.scale.yz;
    }
};

struct SplatViewGeom : IDifferentiable
{
    float2 clipMean;
    float2 axis;
    float2 scale;
};

struct SplatViewColor : IDifferentiable
{
    float depth;
};

struct SplatView : IDifferentiable
{
    SplatViewGeom geom;
    SplatViewColor color;
};

struct SplatViewBuffer
{
    StructuredBuffer<float4> clipMeans_depths;
    StructuredBuffer<float4> axes_scales;

    SplatView load(uint splatViewID)
    {
        float4 clipMean_depth = clipMeans_depths[splatViewID];
        float4 axis_scale = axes_scales[splatViewID];
        SplatView splatView;
        splatView.geom.clipMean = clipMean_depth.xy;
        splatView.color.depth = clipMean_depth.z;
        splatView.geom.axis = axis_scale.xy;
        splatView.geom.scale = axis_scale.zw;
        return splatView;
    }
};

struct RWSplatViewBuffer
{
    RWStructuredBuffer<float4> clipMeans_depths;
    RWStructuredBuffer<float4> axes_scales;

    void store(uint splatViewID, in const SplatView splatView)
    {
        clipMeans_depths[splatViewID] = float4(splatView.geom.clipMean, splatView.color.depth, 0);
        axes_scales[splatViewID] = float4(splatView.geom.axis, splatView.geom.scale);
    }
};

/* struct Pixel
{
    float depth;
    float prodT;
};

struct PixelImage
{
    Texture2D<float2> depths_prodTs;
    Pixel load(uint2 coord) {
        float2 depth_prodT =
    }
} */

[Differentiable]
float viewZ2Depth(float viewZ, no_diff float camNearZ, no_diff float camFarZ)
{
    // Use inversed viewZ as depth
    return camNearZ / -viewZ;
}

[Differentiable]
SplatView splat2splatView(
    Splat splat,
    float3 splatViewPos,
    float3 splatClipPos,
    no_diff float4x4 camViewMat,
    no_diff float4x4 camProjMat,
    no_diff float camNearZ,
    no_diff float camFarZ,
    no_diff float2 camResolution
)
{
    float2x3 cov3d = GS3D::getCovariance3D(splat.rotate, splat.scale);
    float3 cov2d = GS3D::getCovariance2D(cov3d, splatViewPos, float3x3(camViewMat), camProjMat, camResolution);
    GS3D::Eigen<2> eigen2d = GS3D::decomposeCovariance2D(cov2d);
    SplatView splatView;
    splatView.geom.clipMean = splatClipPos.xy;
    splatView.color.depth = viewZ2Depth(splatViewPos.z, camNearZ, camFarZ);
    splatView.geom.axis = eigen2d.eigen[0];
    splatView.geom.scale = sqrt(2.0 * eigen2d.lambda);
    // e^{-d^2} = e^{-\frac{1}{2}(\frac{a}{\sigma})^2} \Rightarrow a = \sqrt{2}\sigma d
    // Let d = 2, a = 2\sqrt{2} \sigma < 3 \sigma
    return splatView;
}

[Differentiable]
SplatView splat2splatView(
    Splat splat,
    no_diff float4x4 camViewMat,
    no_diff float4x4 camProjMat,
    no_diff float camNearZ,
    no_diff float camFarZ,
    no_diff float2 camResolution
)
{
    float3 viewPos = mul(camViewMat, float4(splat.mean, 1)).xyz;
    float4 clipPos = mul(camProjMat, float4(viewPos, 1));
    clipPos /= clipPos.w;
    return splat2splatView(splat, viewPos, clipPos.xyz, camViewMat, camProjMat, camNearZ, camFarZ, camResolution);
}

float2x2 getDeltaClip(SplatViewGeom splatViewGeom, float2 camResolution)
{
    float2 deltaClip0 = splatViewGeom.scale[0] * splatViewGeom.axis * 2 / camResolution;
    float2 deltaClip1 = splatViewGeom.scale[1] * float2(-splatViewGeom.axis.y, splatViewGeom.axis.x) * 2 / camResolution;
    // deltaClip * 2 to scale from [0, 1] to [-1, 1]
    return float2x2(deltaClip0, deltaClip1);
}

[Differentiable]
float getAlpha(SplatViewGeom splatViewGeom, no_diff float2 screenPos, no_diff float2 camResolution)
{
    // clipMean to screenMean
    float2 screenMean = (0.5 * splatViewGeom.clipMean + 0.5) * camResolution;
    float2 quadPos =
        mul(float2x2(
                splatViewGeom.axis / splatViewGeom.scale[0],                                 //
                float2(-splatViewGeom.axis.y, splatViewGeom.axis.x) / splatViewGeom.scale[1] //
            ),
            screenPos - screenMean);
    return exp(-dot(quadPos, quadPos));
}
